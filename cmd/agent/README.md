# cmd/agent

В данной директории будет содержаться код Агента, который скомпилируется в бинарное приложение



%!s(int=0)    |     {/gc/cycles/automatic:gc-cycles Count of completed GC cycles generated by the Go runtime. %!s(metrics.ValueKind=1) %!s(bool=true)}

%!s(int=1)    |     {/gc/cycles/forced:gc-cycles Count of completed GC cycles forced by the application. %!s(metrics.ValueKind=1) %!s(bool=true)}

%!s(int=2)    |     {/gc/cycles/total:gc-cycles Count of all completed GC cycles. %!s(metrics.ValueKind=1) %!s(bool=true)}

%!s(int=3)    |     {/gc/heap/allocs-by-size:bytes Distribution of heap allocations by approximate size. Note that this does not include tiny objects as defined by /gc/heap/tiny/allocs:objects, only tiny blocks. %!s(metrics.ValueKind=3) %!s(bool=true)}

%!s(int=4)    |     {/gc/heap/allocs:bytes Cumulative sum of memory allocated to the heap by the application. %!s(metrics.ValueKind=1) %!s(bool=true)}

%!s(int=5)    |     {/gc/heap/allocs:objects Cumulative count of heap allocations triggered by the application. Note that this does not include tiny objects as defined by /gc/heap/tiny/allocs:objects, only tiny blocks. %!s(metrics.ValueKind=1) %!s(bool=true)}

%!s(int=6)    |     {/gc/heap/frees-by-size:bytes Distribution of freed heap allocations by approximate size. Note that this does not include tiny objects as defined by /gc/heap/tiny/allocs:objects, only tiny blocks. %!s(metrics.ValueKind=3) %!s(bool=true)}

%!s(int=7)    |     {/gc/heap/frees:bytes Cumulative sum of heap memory freed by the garbage collector. %!s(metrics.ValueKind=1) %!s(bool=true)}

%!s(int=8)    |     {/gc/heap/frees:objects Cumulative count of heap allocations whose storage was freed by the garbage collector. Note that this does not include tiny objects as defined by /gc/heap/tiny/allocs:objects, only tiny blocks. %!s(metrics.ValueKind=1) %!s(bool=true)}

%!s(int=9)    |     {/gc/heap/goal:bytes Heap size target for the end of the GC cycle. %!s(metrics.ValueKind=1) %!s(bool=false)}

%!s(int=10)    |     {/gc/heap/objects:objects Number of objects, live or unswept, occupying heap memory. %!s(metrics.ValueKind=1) %!s(bool=false)}

%!s(int=11)    |     {/gc/heap/tiny/allocs:objects Count of small allocations that are packed together into blocks. These allocations are counted separately from other allocations because each individual allocation is not tracked by the runtime, only their block. Each block is already accounted for in allocs-by-size and frees-by-size. %!s(metrics.ValueKind=1) %!s(bool=true)}

%!s(int=12)    |     {/gc/pauses:seconds Distribution individual GC-related stop-the-world pause latencies. %!s(metrics.ValueKind=3) %!s(bool=true)}

%!s(int=13)    |     {/memory/classes/heap/free:bytes Memory that is completely free and eligible to be returned to the underlying system, but has not been. This metric is the runtime's estimate of free address space that is backed by physical memory. %!s(metrics.ValueKind=1) %!s(bool=false)}

%!s(int=14)    |     {/memory/classes/heap/objects:bytes Memory occupied by live objects and dead objects that have not yet been marked free by the garbage collector. %!s(metrics.ValueKind=1) %!s(bool=false)}

%!s(int=15)    |     {/memory/classes/heap/released:bytes Memory that is completely free and has been returned to the underlying system. This metric is the runtime's estimate of free address space that is still mapped into the process, but is not backed by physical memory. %!s(metrics.ValueKind=1) %!s(bool=false)}

%!s(int=16)    |     {/memory/classes/heap/stacks:bytes Memory allocated from the heap that is reserved for stack space, whether or not it is currently in-use. %!s(metrics.ValueKind=1) %!s(bool=false)}

%!s(int=17)    |     {/memory/classes/heap/unused:bytes Memory that is reserved for heap objects but is not currently used to hold heap objects. %!s(metrics.ValueKind=1) %!s(bool=false)}

%!s(int=18)    |     {/memory/classes/metadata/mcache/free:bytes Memory that is reserved for runtime mcache structures, but not in-use. %!s(metrics.ValueKind=1) %!s(bool=false)}

%!s(int=19)    |     {/memory/classes/metadata/mcache/inuse:bytes Memory that is occupied by runtime mcache structures that are currently being used. %!s(metrics.ValueKind=1) %!s(bool=false)}

%!s(int=20)    |     {/memory/classes/metadata/mspan/free:bytes Memory that is reserved for runtime mspan structures, but not in-use. %!s(metrics.ValueKind=1) %!s(bool=false)}

%!s(int=21)    |     {/memory/classes/metadata/mspan/inuse:bytes Memory that is occupied by runtime mspan structures that are currently being used. %!s(metrics.ValueKind=1) %!s(bool=false)}

%!s(int=22)    |     {/memory/classes/metadata/other:bytes Memory that is reserved for or used to hold runtime metadata. %!s(metrics.ValueKind=1) %!s(bool=false)}

%!s(int=23)    |     {/memory/classes/os-stacks:bytes Stack memory allocated by the underlying operating system. %!s(metrics.ValueKind=1) %!s(bool=false)}

%!s(int=24)    |     {/memory/classes/other:bytes Memory used by execution trace buffers, structures for debugging the runtime, finalizer and profiler specials, and more. %!s(metrics.ValueKind=1) %!s(bool=false)}

%!s(int=25)    |     {/memory/classes/profiling/buckets:bytes Memory that is used by the stack trace hash map used for profiling. %!s(metrics.ValueKind=1) %!s(bool=false)}

%!s(int=26)    |     {/memory/classes/total:bytes All memory mapped by the Go runtime into the current process as read-write. Note that this does not include memory mapped by code called via cgo or via the syscall package. Sum of all metrics in /memory/classes. %!s(metrics.ValueKind=1) %!s(bool=false)}

%!s(int=27)    |     {/sched/goroutines:goroutines Count of live goroutines. %!s(metrics.ValueKind=1) %!s(bool=false)}

%!s(int=28)    |     {/sched/latencies:seconds Distribution of the time goroutines have spent in the scheduler in a runnable state before actually running. %!s(metrics.ValueKind=3) %!s(bool=false)}



/gc/cycles/automatic:gc-cycles: 0
/gc/cycles/forced:gc-cycles: 0
/gc/cycles/total:gc-cycles: 0
/gc/heap/allocs-by-size:bytes: 17.000000
/gc/heap/allocs:bytes: 519664
/gc/heap/allocs:objects: 4699
/gc/heap/frees-by-size:bytes: 1.000000
/gc/heap/frees:bytes: 0
/gc/heap/frees:objects: 0
/gc/heap/goal:bytes: 4194304
/gc/heap/objects:objects: 4699
/gc/heap/tiny/allocs:objects: 0
/gc/pauses:seconds: -Inf
/memory/classes/heap/free:bytes: 0
/memory/classes/heap/objects:bytes: 519664
/memory/classes/heap/released:bytes: 3375104
/memory/classes/heap/stacks:bytes: 294912
/memory/classes/heap/unused:bytes: 4624
/memory/classes/metadata/mcache/free:bytes: 12000
/memory/classes/metadata/mcache/inuse:bytes: 19200
/memory/classes/metadata/mspan/free:bytes: 12512
/memory/classes/metadata/mspan/inuse:bytes: 20128
/memory/classes/metadata/other:bytes: 3437864
/memory/classes/os-stacks:bytes: 0
/memory/classes/other:bytes: 774096
/memory/classes/profiling/buckets:bytes: 3512
/memory/classes/total:bytes: 8473616
/sched/goroutines:goroutines: 1
/sched/latencies:seconds: 0.000000


package main

import (
	"fmt"

	"runtime/metrics"

	"github.com/siestacloud/service-monitoring/internal/agent/metricscustom"
)

func main() {

	m := metricscustom.CustomRuntimeMetrics{}
	// Get descriptions for all supported metrics.
	descs := metrics.All()
	for i, x := range descs {
		fmt.Printf("%s    |     %s\n\n", i, x)
	}
	fmt.Println(m, len(descs))
	// Create a sample for each metric.
	samples := make([]metrics.Sample, len(descs))
	for i := range samples {
		samples[i].Name = descs[i].Name
	}
	fmt.Println("==================")
	for i, x := range samples {
		fmt.Printf("%s    |     %s\n\n", i, x)
	}
	// Sample the metrics. Re-use the samples slice if you can!
	metrics.Read(samples)

	// Iterate over all results.
	for _, sample := range samples {
		// Pull out the name and value.
		name, value := sample.Name, sample.Value

		// Handle each sample.
		switch value.Kind() {
		case metrics.KindUint64:
			fmt.Printf("%s: %d\n", name, value.Uint64())
		case metrics.KindFloat64:
			fmt.Printf("%s: %f\n", name, value.Float64())
		case metrics.KindFloat64Histogram:
			// The histogram may be quite large, so let's just pull out
			// a crude estimate for the median for the sake of this example.
			fmt.Printf("%s: %f\n", name, medianBucket(value.Float64Histogram()))
		case metrics.KindBad:
			// This should never happen because all metrics are supported
			// by construction.
			panic("bug in runtime/metrics package!")
		default:
			// This may happen as new metrics get added.
			//
			// The safest thing to do here is to simply log it somewhere
			// as something to look into, but ignore it for now.
			// In the worst case, you might temporarily miss out on a new metric.
			fmt.Printf("%s: unexpected metric Kind: %v\n", name, value.Kind())
		}
	}
}

func medianBucket(h *metrics.Float64Histogram) float64 {
	total := uint64(0)
	for _, count := range h.Counts {
		total += count
	}
	thresh := total / 2
	total = 0
	for i, count := range h.Counts {
		total += count
		if total >= thresh {
			return h.Buckets[i]
		}
	}
	panic("should not happen")
}
